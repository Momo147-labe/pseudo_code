import 'mld_transformer.dart';
import 'sql_utils.dart';

enum SqlDialect { mysql, sqlite, postgresql }

class MpdGenerator {
  static String generate(Mld mld, SqlDialect dialect) {
    final buffer = StringBuffer();

    buffer.writeln('-- SQL Script generated by MERISE Studio');
    buffer.writeln('-- Dialect: ${dialect.name.toUpperCase()}');
    buffer.writeln('-- Date: ${DateTime.now().toString()}');
    buffer.writeln();

    if (dialect == SqlDialect.sqlite) {
      buffer.writeln('PRAGMA foreign_keys = ON;');
      buffer.writeln();
    }

    for (final table in mld.tables) {
      buffer.writeln(_generateCreateTable(table, dialect));
      buffer.writeln();
    }

    return buffer.toString();
  }

  static String _generateCreateTable(MldTable table, SqlDialect dialect) {
    final buffer = StringBuffer();
    final tableName = SqlUtils.quote(table.name, dialect);

    buffer.writeln('CREATE TABLE $tableName (');

    final columnDefs = <String>[];

    for (final col in table.columns) {
      columnDefs.add('  ${_generateColumnDef(col, dialect)}');
    }

    // Clé primaire
    final pkCols = table.columns
        .where((c) => c.isPrimaryKey)
        .map((c) => SqlUtils.quote(c.name, dialect))
        .toList();
    if (pkCols.isNotEmpty) {
      columnDefs.add('  PRIMARY KEY (${pkCols.join(', ')})');
    }

    // Uniques (typically for enforcing 1:1 foreign keys)
    for (final col in table.columns.where((c) => c.isUnique)) {
      columnDefs.add('  UNIQUE (${SqlUtils.quote(col.name, dialect)})');
    }

    // Clés étrangères
    for (final fk in table.foreignKeys) {
      String fkDef =
          '  FOREIGN KEY (${SqlUtils.quote(fk.columnName, dialect)}) REFERENCES ${SqlUtils.quote(fk.referencedTable, dialect)}(${SqlUtils.quote(fk.referencedColumn, dialect)})';
      if (dialect == SqlDialect.mysql || dialect == SqlDialect.postgresql) {
        fkDef += ' ON DELETE CASCADE ON UPDATE CASCADE';
      }
      columnDefs.add(fkDef);
    }

    buffer.write(columnDefs.join(',\n'));
    buffer.writeln('\n);');

    return buffer.toString();
  }

  static String _generateColumnDef(MldColumn col, SqlDialect dialect) {
    String type = _mapType(col.type, dialect);
    String def = '${SqlUtils.quote(col.name, dialect)} $type';

    // Nullability
    if (col.isPrimaryKey || !col.isNullable) {
      def += ' NOT NULL';
    }

    // Pour SQLite, si c'est une PK simple et entière, on peut utiliser AUTOINCREMENT
    // Mais en Merise standard on évite les automatismes SGBD dans le MLD.

    if (col.isPrimaryKey && pkCount(col) == 1 && dialect != SqlDialect.sqlite) {
      // Optionnel : addition de contraintes spécifiques
    }

    return def;
  }

  static int pkCount(MldColumn col) {
    // Note: cette fonction est simpliste ici car elle n'a pas accès à la table entière
    return 1;
  }

  static String _mapType(String conceptType, SqlDialect dialect) {
    final canon = SqlUtils.canonicalType(conceptType);

    switch (dialect) {
      case SqlDialect.mysql:
        switch (canon) {
          case 'int':
            return 'INT';
          case 'date':
            return 'DATE';
          case 'bool':
            return 'TINYINT(1)';
          case 'float':
            return 'DOUBLE';
          case 'text':
            return 'TEXT';
          case 'string':
          default:
            return 'VARCHAR(255)';
        }

      case SqlDialect.postgresql:
        switch (canon) {
          case 'int':
            return 'INTEGER';
          case 'date':
            return 'DATE';
          case 'bool':
            return 'BOOLEAN';
          case 'float':
            return 'DOUBLE PRECISION';
          case 'text':
            return 'TEXT';
          case 'string':
          default:
            return 'VARCHAR(255)';
        }

      case SqlDialect.sqlite:
        switch (canon) {
          case 'int':
            return 'INTEGER';
          case 'date':
            return 'TEXT';
          case 'bool':
            return 'INTEGER';
          case 'float':
            return 'REAL';
          case 'text':
          case 'string':
          default:
            return 'TEXT';
        }
    }
  }
}
